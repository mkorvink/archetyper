---
title: "Introduction to archetyper"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to archetyper}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
ifelse(dir.exists("majestic_12"),unlink("majestic_12", recursive=TRUE), NA)
```

```{r setup}
library(archetyper)
```

The lifecyle of a data mining project generally includes:

* Integration:

* Enrichment

* Modeling

* Measurement

* Presentation

* Deployment

Additionally, a well-formed data mining project will include:


* Centralized code for common libraries, functions, and constants

* Version control

* Unit testing

* A readme file

* Adherence to coding standards

* Externalized properties 

* Logging support


## Generating a new project with `generate()`:  

`generate()` will produce a set of files and directories to support both the data mining workflow and surrounding technical components. 


```{r, include = FALSE}
ifelse(dir.exists("majestic_12"),unlink("majestic_12", recursive=TRUE), NA)
```

```{r}
generate("majestic_12")

list.files("majestic_12/")

```

```{r, include = FALSE}
ifelse(dir.exists("majestic_12"),unlink("majestic_12", recursive=TRUE), NA)
```


The base workflow files include integrate.R, enrich.R, model.R, measure.R, present.Rmd, and api.R.

* `integrate.R` is responsible for integration tasks.  Templated code is provided in the file to demonstrate its use within the larger modeling workflow.  The output of the integration step is a two-by-two tibble object saved in feather format to the /cache directory for downstream use. It is worth noting that the feather file format efficiently stores the data while maintaining datatypes. Feather files can further be read into both R and Python applications, while preserving the metadata included in the data frame itself.
* `enrich.R` is responsible for reading integrated data from the `/cache` directory. As with the integration step, the output of the integration step is a two-by-two tibble object saved as a version-controlled feather file in the `/cache` directory for downstream use.
* `model.R` should read the training partitions from the enriched dataset stored in the `/cache` directory and trains the desired model. Model objects generated within the model.R file should be stored in the `/models` directory using consistent version control and naming conventions.
*	`evaluate.R` should read the testing partitions from the enriched dataset stored in the `/cache` directory and applies the trained model from the `/model` directory. Model results are appended to the testing dataset and are persisted as a plain-text file in the `/results` directory. A feather file is not generated in this step as it this data may be shared with non-technical stakeholders directly.  Visualizations related to performance on the testing dataset, such as ROC Curves and box-plots, model metadata (e.g. coefficients) may be generated at this phase and persisted in the `/cache` directory.
*	`present.Rmd` is an RMarkdown document template that demonstrates the assembly of data and charts stored within both the cache and results directory.  The mediator.R script will knit the Markdown document and store the resulting file into the `/docs` directory.
*	`api.R` is a RESTful api template generated by archetyper. A curl command is included in the file to demonstrate interaction with the deployed API. The API can be tested locally or deployed to an internal server. Note that the `archetyper` API template does not enforce authentication (research) and therefore developers should consult with their security team prior to deploying an API within their organization.  The RESTful service in the `api.R` file is implemented using the `plumber` library.

Additional files are created to serve supporting functions:

*	`test.R` stores unit and integration tests with an example unit test using the testthat library (CITE)
*	`mediator.R` is responsible for the contiguous execution of each component, with conditions to stop execution upon failure at any step.  The `mediator.R` file is named after the Gang of Four mediator pattern (cite) as it orchestrates calls to each component and enforces isolation between them. The mediator.R file  further executes unit tests prior to the execution of the workflow, and additionally has templated code to run a linting process to enforce code styling and formatting best practices.
*	`common.R` is responsible for identifying libraries common across components (e.g. `dplyr`, `stringr`, `magittr`, etc.), as well as project constants. Each component in the workflow sources the common.R file.  
*	`utilities.R` is designed to store functions that are necessary across components. The `common.R` file sources the utilities.R file, and in turn, each 
*	`.gitignore` excludes commonly ignored R objects (e.g. provide examples).  The `.gitignore` file is further updated to exclude the `config.yml` file so that a externalized user database credentials are not committed into a shared source code repository.  The base .gitignore file included in the archetyper template was generated from the `gitignore` r package.
*	`lint.R` includes linting commands for each file in the workflow to enforce proper style and syntax conventions
*	`readme.md` is designed to provide project documentation and details on how the user will interact with the code.


A directory structure designed to logically separate the data artifacts produced throughout the workflow. These directories include:

*	`/source_data` is used to store unprocessed data read in through the `integration.R` file
*	`/cache` stores working data throughout the data mining workflow. This data includes versioned snapshots of both integrated and enriched data as well as other files and objects that might be necessary to present findings from the model.
*	`/models` stores version controlled model objects
*	`/result_data` stores version-controlled plain-text files with the appended model results. 


For traceability, files and object (e.g. models) throughout the project are named according to a standard naming convention. (note snakecase as a helpful library)
This structure, in conjunction with the persistent state of each component, allows each component script to be run independently without sourcing all the preceding components.

`[ project_name ]_[ file_name ]_[ YYYY_MM_DD_HH:MM ].[ file_extension ]`


### Database connections


A database connection type of “odbc” or “jdbc” can be passed in as a function argument to generate scaffolding helpful for database connections.  Example code demonstrating the database connection will be generated in the integrate.R file. The following files will also be generated with a “odbc” or ‘jdbc” argument:

* `dml_ddl.sql` for storing SQL statements and other database scripts used to prepare and extract data from the source systems, 
* `config.yml` for storing secret database

If using JDBC, a directory for driver JARs named `/drivers` will also be created:

*	`/drivers` is directory for storing directory for storing database driver jars, and 4) file to connect to a database using both the credentials stored in the `config.yml` and jars stored in the `/driver` directory.  Note that the user must provide the jars and classpath names to the jars specific to the database type being accessed.

```{r}
archetyper::generate("majestic_12", db_connection_type = 'jdbc')
list.files("majestic_12/")
```

```{r, include = FALSE}
ifelse(dir.exists("majestic_12"),unlink("majestic_12", recursive=TRUE), NA)
```

### Excluding components

```{r}
archetyper::generate("majestic_12",  exclude = c("api", "utilities", "readme", "lint", "gitignore"))

list.files("majestic_12/")
```

```{r, include = FALSE}
ifelse(dir.exists("majestic_12"),unlink("majestic_12", recursive=TRUE), NA)
```
## Generating the demo project

```{r}
#archetyper::generate_demo()
```

The the full code life-cycle can be triggered by executing the `mediator.R` script:


```{r}
#source("mediator.R")

```

Version-controlled feature files produced by the integration and enrichment components. Lightweight storage. Minimizes unnecessary reprocessing.  Data has observations as rows and features as columns. (Describe more)

```{r}
#source("mediator.R")
#list.files("readmission_analysis/cache")
```


TODO: Show the head of the integrate and erich file (to show that it is tidy data and to distinguish the type of data between integrate and enrich).  Show that training labels have been added to the enrich data

Models are persisted

```{r}
#source("mediator.R")
#list.files("readmission_analysis/models")
```

show that predictions have been applied to the test data in plain text format

```{r}
#source("mediator.R")
#list.files("readmission_analysis/results")
```


Show that markdown doc was created

```{r}
#source("mediator.R")
#list.files("readmission_analysis/docs")
```



TODO: Think about cat(file.r) to show the contents in each file.


